use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{FromRow, PgPool};
// use std::collections::HashMap;
// use std::sync::Arc;
// use tokio::sync::RwLock;

/// A single recipient in a campaign
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Recipient {
    #[serde(skip_deserializing)] // Generated by DB or ignored
    pub id: Option<i32>,
    pub wallet: String,
    pub amount: f64,
    pub claimed: bool,
    pub claimed_at: Option<DateTime<Utc>>,
}

/// Campaign data stored in the backend
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Campaign {
    pub id: String,
    pub address: String,
    pub name: String,
    pub merkle_root: String,
    pub total_amount: f64,
    pub creator_wallet: String,
    pub tx_signature: Option<String>,
    pub vault_address: Option<String>,
    pub created_at: DateTime<Utc>,
    #[sqlx(skip)]
    pub recipients: Vec<Recipient>, // Populated manually
    // Vesting fields
    pub airdrop_type: String, 
    pub vesting_start: i64,
    pub vesting_cliff_seconds: i64,
    pub vesting_duration_seconds: i64,
    // Token fields (None = SOL campaign)
    pub token_mint: Option<String>,
    pub token_symbol: Option<String>,
    pub token_decimals: Option<u8>, // u8 is smallint in postgres, but sqlx maps smallint to i16 usually. We might need specific handling or cast.
                                    // Actually sqlx maps SMALLINT to i16. u8 might be tricky. Let's try casting or changing type if needed.
                                    // For now, let's keep u8 and see if sqlx handles it or if we need `try_from`.
                                    // SAFEST: Store as i16 in struct or handle cast.
                                    // But to minimize changes, let's decorate with `sqlx(try_from = "i16")` if needed.
                                    // Actually, simplest is to use `i16` in struct? No, that breaks other code.
                                    // Let's rely on standard mapping or manual fetch.
}

// Helper to handle the u8/i16 mismatch if automatic FromRow fails:
// We will manually query campaigns anyway because of the `recipients` vec.

/// Response for campaign info (without recipient list for privacy)
#[derive(Debug, Serialize)]
pub struct CampaignInfo {
    pub id: String,
    pub address: String,
    pub name: String,
    pub total_amount: f64,
    pub total_recipients: usize,
    pub claimed_count: usize,
    pub creator_wallet: String,
    pub vault_address: Option<String>, // PDA vault address for claims
    pub tx_signature: Option<String>,
    pub created_at: DateTime<Utc>,
    // Token fields (None = SOL campaign)
    pub token_mint: Option<String>,
    pub token_symbol: Option<String>,
    pub token_decimals: Option<u8>,
}

impl From<&Campaign> for CampaignInfo {
    fn from(campaign: &Campaign) -> Self {
        CampaignInfo {
            id: campaign.id.clone(),
            address: campaign.address.clone(),
            name: campaign.name.clone(),
            total_amount: campaign.total_amount,
            total_recipients: campaign.recipients.len(),
            claimed_count: campaign.recipients.iter().filter(|r| r.claimed).count(),
            creator_wallet: campaign.creator_wallet.clone(),
            vault_address: campaign.vault_address.clone(),
            tx_signature: campaign.tx_signature.clone(),
            created_at: campaign.created_at,
            token_mint: campaign.token_mint.clone(),
            token_symbol: campaign.token_symbol.clone(),
            token_decimals: campaign.token_decimals,
        }
    }
}

/// Eligibility check response
#[derive(Debug, Serialize)]
pub struct EligibilityResponse {
    pub eligible: bool,
    pub amount: Option<f64>,
    pub already_claimed: bool,
}

/// Eligible campaign info for a wallet
#[derive(Debug, Serialize)]
pub struct EligibleCampaign {
    pub address: String,
    pub name: String,
    pub amount: f64,
    pub total_amount: f64,
    pub total_recipients: usize,
    pub vault_address: Option<String>,
    pub created_at: DateTime<Utc>,
    pub token_symbol: Option<String>,
    pub token_decimals: Option<u8>,
}

/// Persistent campaign store using PostgreSQL
#[derive(Debug, Clone)]
pub struct CampaignStore {
    db: PgPool,
}

impl CampaignStore {
    pub fn new(db: PgPool) -> Self {
        Self { db }
    }

    /// Create a new campaign
    pub async fn create(&self, campaign: Campaign) -> Campaign {
        let mut tx = self.db.begin().await.expect("Failed to begin transaction");

        // Insert campaign
        sqlx::query!(
            r#"
            INSERT INTO campaigns (
                id, address, name, merkle_root, total_amount, creator_wallet, 
                tx_signature, vault_address, created_at, airdrop_type, 
                vesting_start, vesting_cliff_seconds, vesting_duration_seconds, 
                token_mint, token_symbol, token_decimals
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
            "#,
            campaign.id,
            campaign.address,
            campaign.name,
            campaign.merkle_root,
            campaign.total_amount,
            campaign.creator_wallet,
            campaign.tx_signature,
            campaign.vault_address,
            campaign.created_at,
            campaign.airdrop_type,
            campaign.vesting_start,
            campaign.vesting_cliff_seconds,
            campaign.vesting_duration_seconds,
            campaign.token_mint,
            campaign.token_symbol,
            campaign.token_decimals.map(|d| d as i16) // Cast u8 to i16 for SMALLINT
        )
        .execute(&mut *tx)
        .await
        .expect("Failed to insert campaign");

        // Insert recipients
        // Bulk insert is more efficient, but let's do simple loop for now or unnest.
        // For simplicity in this step, simple loop.
        for r in &campaign.recipients {
            sqlx::query!(
                r#"
                INSERT INTO recipients (campaign_address, wallet, amount, claimed, claimed_at)
                VALUES ($1, $2, $3, $4, $5)
                "#,
                campaign.address,
                r.wallet,
                r.amount,
                r.claimed,
                r.claimed_at
            )
            .execute(&mut *tx)
            .await
            .expect("Failed to insert recipient");
        }

        tx.commit().await.expect("Failed to commit transaction");

        campaign
    }

    /// Get a campaign by address
    pub async fn get(&self, address: &str) -> Option<Campaign> {
        let rec = sqlx::query!(
            "SELECT * FROM campaigns WHERE address = $1",
            address
        )
        .fetch_optional(&self.db)
        .await
        .ok()??;

        // Fetch recipients
        let recipients = sqlx::query_as!(
            Recipient,
            r#"
            SELECT id, wallet, amount, claimed, claimed_at 
            FROM recipients 
            WHERE campaign_address = $1
            "#,
            address
        )
        .fetch_all(&self.db)
        .await
        .unwrap_or_default();

        Some(Campaign {
            id: rec.id,
            address: rec.address,
            name: rec.name,
            merkle_root: rec.merkle_root,
            total_amount: rec.total_amount,
            creator_wallet: rec.creator_wallet,
            tx_signature: rec.tx_signature,
            vault_address: rec.vault_address,
            created_at: rec.created_at,
            recipients,
            airdrop_type: rec.airdrop_type,
            vesting_start: rec.vesting_start,
            vesting_cliff_seconds: rec.vesting_cliff_seconds,
            vesting_duration_seconds: rec.vesting_duration_seconds,
            token_mint: rec.token_mint,
            token_symbol: rec.token_symbol,
            token_decimals: rec.token_decimals.map(|d| d as u8),
        })
    }

    /// Get all campaigns for a wallet
    pub async fn get_by_wallet(&self, wallet: &str) -> Vec<Campaign> {
        let campaigns_recs = sqlx::query!(
            "SELECT address FROM campaigns WHERE creator_wallet = $1 ORDER BY created_at DESC",
            wallet
        )
        .fetch_all(&self.db)
        .await
        .unwrap_or_default();

        let mut results = Vec::new();
        for crec in campaigns_recs {
            if let Some(c) = self.get(&crec.address).await {
                results.push(c);
            }
        }
        results
    }

    /// Check eligibility for a wallet in a campaign
    pub async fn check_eligibility(&self, address: &str, wallet: &str) -> Option<EligibilityResponse> {
        // We only need to check the recipients table, much faster!
        let recipient = sqlx::query!(
            "SELECT amount, claimed FROM recipients WHERE campaign_address = $1 AND wallet = $2",
            address,
            wallet
        )
        .fetch_optional(&self.db)
        .await
        .ok()?;

        Some(match recipient {
            Some(r) => EligibilityResponse {
                eligible: !r.claimed,
                amount: Some(r.amount),
                already_claimed: r.claimed,
            },
            None => EligibilityResponse {
                eligible: false,
                amount: None,
                already_claimed: false,
            },
        })
    }

    /// Mark a recipient as claimed
    pub async fn mark_claimed(&self, address: &str, wallet: &str) -> bool {
        let result = sqlx::query!(
            r#"
            UPDATE recipients 
            SET claimed = true, claimed_at = $1 
            WHERE campaign_address = $2 AND wallet = $3 AND claimed = false
            "#,
            Utc::now(),
            address,
            wallet
        )
        .execute(&self.db)
        .await;

        match result {
            Ok(res) => res.rows_affected() > 0,
            Err(_) => false,
        }
    }

    /// Get all campaigns where the wallet is eligible to claim
    pub async fn get_eligible_for_wallet(&self, wallet: &str) -> Vec<EligibleCampaign> {
        // Join campaigns and recipients
        let rows = sqlx::query!(
            r#"
            SELECT c.address, c.name, c.total_amount, c.vault_address, c.created_at, 
                   c.token_symbol, c.token_decimals,
                   r.amount,
                   (SELECT COUNT(*) FROM recipients WHERE campaign_address = c.address) as total_recipients
            FROM campaigns c
            JOIN recipients r ON c.address = r.campaign_address
            WHERE r.wallet = $1 AND r.claimed = false
            "#,
            wallet
        )
        .fetch_all(&self.db)
        .await
        .unwrap_or_default();

        rows.into_iter().map(|row| EligibleCampaign {
            address: row.address,
            name: row.name,
            amount: row.amount,
            total_amount: row.total_amount,
            total_recipients: row.total_recipients.unwrap_or(0) as usize,
            vault_address: row.vault_address,
            created_at: row.created_at,
            token_symbol: row.token_symbol,
            token_decimals: row.token_decimals.map(|d| d as u8),
        }).collect()
    }
}
