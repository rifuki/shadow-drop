//! ZK Types for Sunspot proof generation

use serde::{Deserialize, Serialize};

/// Groth16 proof size: 256 bytes
pub const GROTH16_PROOF_SIZE: usize = 256;

/// Public inputs size: 3 Field elements = 96 bytes
pub const PUBLIC_INPUTS_SIZE: usize = 96;

/// Input for ZK proof generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkProofInput {
    /// Merkle root (32 bytes hex)
    pub merkle_root: String,
    /// Nullifier hash (32 bytes hex)
    pub nullifier_hash: String,
    /// Recipient address as field element (32 bytes hex)
    pub recipient: String,
    /// Claim amount (as string for large numbers)
    pub amount: String,
    /// Secret for nullifier derivation (32 bytes hex)
    pub secret: String,
    /// Leaf index in merkle tree
    pub leaf_index: u64,
    /// Merkle proof path (8 sibling hashes, each 32 bytes hex)
    pub merkle_path: Vec<String>,
}

/// Generated ZK proof data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZkProofOutput {
    /// Groth16 proof bytes (256 bytes, hex encoded)
    pub proof: String,
    /// Public inputs bytes (96 bytes, hex encoded)
    pub public_inputs: String,
    /// Merkle root (for verification)
    pub merkle_root: String,
    /// Nullifier hash (for Light Protocol)
    pub nullifier_hash: String,
}

impl ZkProofInput {
    /// Generate Prover.toml content for Noir circuit
    pub fn to_prover_toml(&self) -> String {
        let mut toml = String::new();

        toml.push_str("# Auto-generated by Shadow Drop backend\n\n");

        // Public inputs
        toml.push_str(&format!("merkle_root = \"{}\"\n", self.merkle_root));
        toml.push_str(&format!("nullifier_hash = \"{}\"\n", self.nullifier_hash));
        toml.push_str(&format!("recipient = \"{}\"\n", self.recipient));
        toml.push_str("\n");

        // Private inputs
        toml.push_str(&format!("amount = \"{}\"\n", self.amount));
        toml.push_str(&format!("secret = \"{}\"\n", self.secret));
        toml.push_str(&format!("leaf_index = \"{}\"\n", self.leaf_index));
        toml.push_str("\n");

        // Merkle path
        toml.push_str("merkle_path = [\n");
        for (i, sibling) in self.merkle_path.iter().enumerate() {
            if i < self.merkle_path.len() - 1 {
                toml.push_str(&format!("    \"{}\",\n", sibling));
            } else {
                toml.push_str(&format!("    \"{}\"\n", sibling));
            }
        }
        toml.push_str("]\n");

        toml
    }
}
